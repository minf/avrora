<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.4.2_07) on Sat Jul 23 14:55:01 PDT 2005 -->
<TITLE>
AbstractArithmetic
</TITLE>

<META NAME="keywords" CONTENT="avrora.stack.AbstractArithmetic class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="AbstractArithmetic";
}
</SCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../avrora/stack/AbstractInterpreter.html" title="class in avrora.stack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractArithmetic.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
avrora.stack</FONT>
<BR>
Class AbstractArithmetic</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by"><B>avrora.stack.AbstractArithmetic</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../avrora/stack/AbstractInterpreter.html" title="class in avrora.stack">AbstractInterpreter</A></DD>
</DL>
<HR>
<DL>
<DT>public class <B>AbstractArithmetic</B><DT>extends java.lang.Object</DL>

<P>
The <code>AbstractArithmetic</code> arithmetic class implements operations that are useful for working on
 abstract integers which are represented as characters. <br><br>
 <p/>
 The abstract values (e.g. register values) are represented as characters. Thus, an 8 bit register is
 modelled using a 16-bit character. The upper 8 bits represent the "mask", those bits which are known. The
 lower 8 bits represent the known bits of the value. Thus, if bit(regs[R], i+8) is set, then bit(R, i) is
 known and its value is bit(regs[R], i). If bit(regs[R], i+8) is clear, then the value of bit(regs[R], i) is
 unknown in this abstract value. <br><br>
 <p/>
 Since there are 3 possible values (on, off, unknown) for each bit in the abstract state and there are two
 bits reserved for representing each of these states, there are 4 bit states to represent 3 values. We
 canonicalize the values when the bit value is unknown, i.e. when the known mask bit is clear, then the
 value bit is clear as well. This makes comparison of canonical abstract values the same as character
 equality. All abstract values stored within <code>AbstractState</code> are canonical for efficiency and
 clarity.
<P>

<P>
<HR>

<P>
<!-- ======== NESTED CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#FALSE">FALSE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>FALSE</code> field represents the abstract bit that is known to be false.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#TRUE">TRUE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>TRUE</code> field represents the abstract bit that is known to be true.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#UNKNOWN">UNKNOWN</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>UNKNOWN</code> field represents the abstract value where none of the bits are known.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#ZERO">ZERO</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>ZERO</code> field represents the abstract value where all bits are known to be zero.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#AbstractArithmetic()">AbstractArithmetic</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#add(char, char)">add</A></B>(char&nbsp;av1,
    char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>add()</code> method performs addition of two abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#and(char, char)">and</A></B>(char&nbsp;av1,
    char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>and()</code> method computes the logical bitwise AND of two abstract values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#and(char, char, char)">and</A></B>(char&nbsp;av1,
    char&nbsp;av2,
    char&nbsp;av3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>and()</code> method computes the logical bitwise AND of three abstract values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#areEqual(char, char)">areEqual</A></B>(char&nbsp;val1,
         char&nbsp;val2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>areEqual()</code> method tests whether two abstract values are equivalent in the "abstract
 value" sense. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#areKnown(char, char)">areKnown</A></B>(char&nbsp;av1,
         char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>areKnown()</code> method tests whether two abstract values each represent a single, fully
 known value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#bitsOf(char)">bitsOf</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>bitsOf()</code> method returns the lower 8 bits (the value bits) of the abstract value,
 ignoring the known bit mask. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#bitToChar(char)">bitToChar</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>toString()</code> method converts an 1-bit abstract value to a string representation. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#canon(char)">canon</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>canon()</code> method canonicalizes an abstract value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#canon(char, char)">canon</A></B>(char&nbsp;mask,
      char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>canon()</code> method canonicalizes an abstract value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#ceiling(char)">ceiling</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>ceiling()</code> function computes the concrete value with all unknown bits set to one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#ceiling(char, char)">ceiling</A></B>(char&nbsp;av1,
        char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>ceiling()</code> function computes the concrete value with all unknown bits set to one. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#commonMask(char, char)">commonMask</A></B>(char&nbsp;av1,
           char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>commonMask()</code> method computes the intersection of the known bit masks of two abstract
 values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#commonMask(char, char, char)">commonMask</A></B>(char&nbsp;av1,
           char&nbsp;av2,
           char&nbsp;av3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>commonMask()</code> method computes the intersection of the known bit masks of three abstract
 values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#couldBeEqual(char, char)">couldBeEqual</A></B>(char&nbsp;av1,
             char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>couldBeEqual()</code> method performs a "fuzzy" equality test between two abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#couldBeZero(char)">couldBeZero</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>couldBeZero</code> method performs a "fuzzy" equality test against zero for an abstract
 value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#couldBeZero(char, char)">couldBeZero</A></B>(char&nbsp;av1,
            char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>couldBeZero()</code> method performs a "fuzzy" equality test against zero for two abstract
 values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#decrement(char)">decrement</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>decrement()</code> method simply subtracts 1 to the abstract value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#floor(char)">floor</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>floor()</code> function computes the concrete value with all unknown bits set to zero. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#floor(char, char)">floor</A></B>(char&nbsp;av1,
      char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>floor()</code> function computes the concrete value with all unknown bits set to zero. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#getBit(char, int)">getBit</A></B>(char&nbsp;av1,
       int&nbsp;bit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>getBit()</code> method extracts the specified abstract bit from the specified abstract
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#increment(char)">increment</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>increment()</code> method simply adds 1 to the abstract value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#isUnknown(char)">isUnknown</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>isKnown()</code> method tests whether an abstract value represents a single, fully known
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#knownBitsOf(char)">knownBitsOf</A></B>(char&nbsp;val)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>knownBitsOf()</code> method returns computes the concrete value from the given abstract value
 where all unknown bits of the abstract value are set to zero.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#knownVal(byte)">knownVal</A></B>(byte&nbsp;cv1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>knownVal()</code> method creates a canonical abstract value from the given concrete value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#logicalAnd(char, char)">logicalAnd</A></B>(char&nbsp;av1,
           char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>logicalAnd</code> method computes the logical bitwise AND of two abstract values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#maskOf(char)">maskOf</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>maskOf()</code> method returns the upper 8 bits of the abstract (the mask bits) of the
 abstract value. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#merge(byte, byte)">merge</A></B>(byte&nbsp;cv1,
      byte&nbsp;cv2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>merge()</code> method merges abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#merge(byte, byte, byte)">merge</A></B>(byte&nbsp;cv1,
      byte&nbsp;cv2,
      byte&nbsp;cv3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>merge()</code> method merges abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#merge(byte, byte, byte, byte)">merge</A></B>(byte&nbsp;cv1,
      byte&nbsp;cv2,
      byte&nbsp;cv3,
      byte&nbsp;cv4)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>merge()</code> method merges abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#merge(char, byte)">merge</A></B>(char&nbsp;av1,
      byte&nbsp;cv2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>merge()</code> method merges abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#merge(char, char)">merge</A></B>(char&nbsp;av1,
      char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>merge()</code> method merges abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#mergeMask(char, char)">mergeMask</A></B>(char&nbsp;mask,
          char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>mergeMask()</code> merges the given abstract value with the known bit mask passed. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#not(char)">not</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>not()</code> method computes the bitwise negation (one's complement) of the specified
 abstract value</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#or(char, char)">or</A></B>(char&nbsp;av1,
   char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>or()</code> method computes the logical bitwise or of two abstract values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#or(char, char, char)">or</A></B>(char&nbsp;av1,
   char&nbsp;av2,
   char&nbsp;av3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>or()</code> method computes the logical bitwise or of three abstract values.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#setBit(char, int, char)">setBit</A></B>(char&nbsp;av1,
       int&nbsp;bit,
       char&nbsp;on)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>setBit()</code> method updates the specified abstract bit within the specified abstract
 value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#shiftLeftOne(char)">shiftLeftOne</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>shiftLeftOne()</code> method shifts the abstract value left by one bit.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#shiftLeftOne(char, char)">shiftLeftOne</A></B>(char&nbsp;av1,
             char&nbsp;lowbit)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>shiftLeftOne()</code> method shifts the abstract value left by one bit and sets the lowest
 bit to the given value.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#subtract(char, char)">subtract</A></B>(char&nbsp;av1,
         char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>add()</code> method performs subtraction of two abstract values. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#toShortString(char)">toShortString</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>toShortString()</code> method converts an 8-bit abstract value to a string representation.
 </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;java.lang.String</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#toString(char)">toString</A></B>(char&nbsp;av1)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>toString()</code> method converts an 8-bit abstract value to a string representation. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#toString(char, java.lang.StringBuffer)">toString</A></B>(char&nbsp;av1,
         java.lang.StringBuffer&nbsp;buf)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>toString()</code> method converts an 8-bit abstract value to a string representation and
 appends it to the end of the given string buffer. </TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;char</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../avrora/stack/AbstractArithmetic.html#xor(char, char)">xor</A></B>(char&nbsp;av1,
    char&nbsp;av2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>xor()</code> method computes the bitwise exclusive or operation on the two given abstract
 values.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.Object</B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="ZERO"><!-- --></A><H3>
ZERO</H3>
<PRE>
public static final char <B>ZERO</B></PRE>
<DL>
<DD>The <code>ZERO</code> field represents the abstract value where all bits are known to be zero.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#avrora.stack.AbstractArithmetic.ZERO">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TRUE"><!-- --></A><H3>
TRUE</H3>
<PRE>
public static final char <B>TRUE</B></PRE>
<DL>
<DD>The <code>TRUE</code> field represents the abstract bit that is known to be true.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#avrora.stack.AbstractArithmetic.TRUE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="FALSE"><!-- --></A><H3>
FALSE</H3>
<PRE>
public static final char <B>FALSE</B></PRE>
<DL>
<DD>The <code>FALSE</code> field represents the abstract bit that is known to be false.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#avrora.stack.AbstractArithmetic.FALSE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="UNKNOWN"><!-- --></A><H3>
UNKNOWN</H3>
<PRE>
public static final char <B>UNKNOWN</B></PRE>
<DL>
<DD>The <code>UNKNOWN</code> field represents the abstract value where none of the bits are known.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../constant-values.html#avrora.stack.AbstractArithmetic.UNKNOWN">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="AbstractArithmetic()"><!-- --></A><H3>
AbstractArithmetic</H3>
<PRE>
public <B>AbstractArithmetic</B>()</PRE>
<DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="merge(byte, byte)"><!-- --></A><H3>
merge</H3>
<PRE>
public static char <B>merge</B>(byte&nbsp;cv1,
                         byte&nbsp;cv2)</PRE>
<DL>
<DD>The <code>merge()</code> method merges abstract values. The merge of two abstract values is defined
 intuitively as the intersection of the known bits of the two values that agree, and all other bits are
 unknown. This variant of the method accepts two concrete values to merge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cv1</CODE> - the first (concrete) value to merge<DD><CODE>cv2</CODE> - the second (concrete) value to merge
<DT><B>Returns:</B><DD>the abstract value representing the results of merging the two values</DL>
</DD>
</DL>
<HR>

<A NAME="merge(char, byte)"><!-- --></A><H3>
merge</H3>
<PRE>
public static char <B>merge</B>(char&nbsp;av1,
                         byte&nbsp;cv2)</PRE>
<DL>
<DD>The <code>merge()</code> method merges abstract values. The merge of two abstract values is defined
 intuitively as the intersection of the known bits of the two values that agree, and all other bits are
 unknown. This variant of the method accepts one abstract value and one concrete value to merge
 together.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first (abstract) value to merge<DD><CODE>cv2</CODE> - the second (concrete) value to merge
<DT><B>Returns:</B><DD>the abstract value representing the results of merging the two values</DL>
</DD>
</DL>
<HR>

<A NAME="merge(byte, byte, byte)"><!-- --></A><H3>
merge</H3>
<PRE>
public static char <B>merge</B>(byte&nbsp;cv1,
                         byte&nbsp;cv2,
                         byte&nbsp;cv3)</PRE>
<DL>
<DD>The <code>merge()</code> method merges abstract values. The merge of two abstract values is defined
 intuitively as the intersection of the known bits of the two values that agree, and all other bits are
 unknown. This variant of the method accepts three concrete values to merge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cv1</CODE> - the first (concrete) value to merge<DD><CODE>cv2</CODE> - the second (concrete) value to merge<DD><CODE>cv3</CODE> - the third (concrete) value to merge
<DT><B>Returns:</B><DD>the abstract value representing the results of merging the two values</DL>
</DD>
</DL>
<HR>

<A NAME="merge(byte, byte, byte, byte)"><!-- --></A><H3>
merge</H3>
<PRE>
public static char <B>merge</B>(byte&nbsp;cv1,
                         byte&nbsp;cv2,
                         byte&nbsp;cv3,
                         byte&nbsp;cv4)</PRE>
<DL>
<DD>The <code>merge()</code> method merges abstract values. The merge of two abstract values is defined
 intuitively as the intersection of the known bits of the two values that agree, and all other bits are
 unknown. This variant of the method accepts four concrete values to merge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cv1</CODE> - the first (concrete) value to merge<DD><CODE>cv2</CODE> - the second (concrete) value to merge<DD><CODE>cv3</CODE> - the third (concrete) value to merge<DD><CODE>cv4</CODE> - the fourth (concrete) value to merge
<DT><B>Returns:</B><DD>the abstract value representing the results of merging the two values</DL>
</DD>
</DL>
<HR>

<A NAME="merge(char, char)"><!-- --></A><H3>
merge</H3>
<PRE>
public static char <B>merge</B>(char&nbsp;av1,
                         char&nbsp;av2)</PRE>
<DL>
<DD>The <code>merge()</code> method merges abstract values. The merge of two abstract values is defined
 intuitively as the intersection of the known bits of the two values that agree, and all other bits are
 unknown. This variant of the method accepts two abstract values to merge.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first (abstract) value to merge<DD><CODE>av2</CODE> - the second (abstract) value to merge
<DT><B>Returns:</B><DD>the abstract value representing the results of merging the two values</DL>
</DD>
</DL>
<HR>

<A NAME="isUnknown(char)"><!-- --></A><H3>
isUnknown</H3>
<PRE>
public static boolean <B>isUnknown</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>isKnown()</code> method tests whether an abstract value represents a single, fully known
 value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to test
<DT><B>Returns:</B><DD>true if all of the bits of the abstract value are known; false if any bits are unknown</DL>
</DD>
</DL>
<HR>

<A NAME="areKnown(char, char)"><!-- --></A><H3>
areKnown</H3>
<PRE>
public static boolean <B>areKnown</B>(char&nbsp;av1,
                               char&nbsp;av2)</PRE>
<DL>
<DD>The <code>areKnown()</code> method tests whether two abstract values each represent a single, fully
 known value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value to test<DD><CODE>av2</CODE> - the second abstract value to test
<DT><B>Returns:</B><DD>true if all of the bits of the both abstract values are known; false if any bits are unknown</DL>
</DD>
</DL>
<HR>

<A NAME="areEqual(char, char)"><!-- --></A><H3>
areEqual</H3>
<PRE>
public static boolean <B>areEqual</B>(char&nbsp;val1,
                               char&nbsp;val2)</PRE>
<DL>
<DD>The <code>areEqual()</code> method tests whether two abstract values are equivalent in the "abstract
 value" sense. Two abstract values are equivalent if their known bits are equal and their known masks
 are equal
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val1</CODE> - the first abstract value<DD><CODE>val2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>true if the abstract values are equal; false otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="canon(char)"><!-- --></A><H3>
canon</H3>
<PRE>
public static char <B>canon</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>canon()</code> method canonicalizes an abstract value. An abstract value is canonical if all
 of its unknown bits are set to zero. This variant takes a single abstract value and ensures that it is
 canonical.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to canonicalize
<DT><B>Returns:</B><DD>the canonicalized representation of this abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="canon(char, char)"><!-- --></A><H3>
canon</H3>
<PRE>
public static char <B>canon</B>(char&nbsp;mask,
                         char&nbsp;av1)</PRE>
<DL>
<DD>The <code>canon()</code> method canonicalizes an abstract value. An abstract value is canonical if all
 of its unknown bits are set to zero. This variant takes a mask and an abstract value and returns an
 abstract value that is canonical with the specified known bit mask.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - the known bit mask to canonicalize with respect to<DD><CODE>av1</CODE> - the abstract value to canonicalize
<DT><B>Returns:</B><DD>the canonicalized representation of this abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="knownVal(byte)"><!-- --></A><H3>
knownVal</H3>
<PRE>
public static char <B>knownVal</B>(byte&nbsp;cv1)</PRE>
<DL>
<DD>The <code>knownVal()</code> method creates a canonical abstract value from the given concrete value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cv1</CODE> - the concrete value to create an abstract value for
<DT><B>Returns:</B><DD>a canonical abstract value representing the concrete value.</DL>
</DD>
</DL>
<HR>

<A NAME="knownBitsOf(char)"><!-- --></A><H3>
knownBitsOf</H3>
<PRE>
public static byte <B>knownBitsOf</B>(char&nbsp;val)</PRE>
<DL>
<DD>The <code>knownBitsOf()</code> method returns computes the concrete value from the given abstract value
 where all unknown bits of the abstract value are set to zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>val</CODE> - the abstract value to get the known bits of
<DT><B>Returns:</B><DD>a concrete value such that all unknown bits are set to zero</DL>
</DD>
</DL>
<HR>

<A NAME="bitsOf(char)"><!-- --></A><H3>
bitsOf</H3>
<PRE>
public static char <B>bitsOf</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>bitsOf()</code> method returns the lower 8 bits (the value bits) of the abstract value,
 ignoring the known bit mask. For a canonical abstract value, this method will return the same result as
 <code>knownBitsOf</code>, because, by definition, the unknown bits of a canonical abstract value are
 set to zero.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>the lower bits of the abstract value as a concrete value</DL>
</DD>
</DL>
<HR>

<A NAME="maskOf(char)"><!-- --></A><H3>
maskOf</H3>
<PRE>
public static char <B>maskOf</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>maskOf()</code> method returns the upper 8 bits of the abstract (the mask bits) of the
 abstract value. This mask represents those bits that are known.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>the mask of known bits of the abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="getBit(char, int)"><!-- --></A><H3>
getBit</H3>
<PRE>
public static char <B>getBit</B>(char&nbsp;av1,
                          int&nbsp;bit)</PRE>
<DL>
<DD>The <code>getBit()</code> method extracts the specified abstract bit from the specified abstract
 value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value<DD><CODE>bit</CODE> - the bit number
<DT><B>Returns:</B><DD><code>AbstractArithmetic.TRUE</code> if the bit is known to be on;
         <code>AbstractArithmetic.FALSE</code> if the bit is known to be off;
         <code>AbstractArithmetic.UNKNOWN</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="setBit(char, int, char)"><!-- --></A><H3>
setBit</H3>
<PRE>
public static char <B>setBit</B>(char&nbsp;av1,
                          int&nbsp;bit,
                          char&nbsp;on)</PRE>
<DL>
<DD>The <code>setBit()</code> method updates the specified abstract bit within the specified abstract
 value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value<DD><CODE>bit</CODE> - the bit number<DD><CODE>on</CODE> - the new abstract value of the bit
<DT><B>Returns:</B><DD>a new abstract value where the specified bit has been replaced with the specified abstract
         value</DL>
</DD>
</DL>
<HR>

<A NAME="couldBeZero(char)"><!-- --></A><H3>
couldBeZero</H3>
<PRE>
public static char <B>couldBeZero</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>couldBeZero</code> method performs a "fuzzy" equality test against zero for an abstract
 value. It will return one of three values, depending on whether the specified abstract value is
 definately zero, definately not zero, or unknown.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD><code>AbstractArithmetic.TRUE</code> if the specified abstract value is definately zero;
         <code>AbstractArithmetic.FALSE</code> if the specified abstract value cannot possibly be zero
         (it has one bit that is known to be on); <code>AbstractArithmetic.UNKNOWN</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="couldBeZero(char, char)"><!-- --></A><H3>
couldBeZero</H3>
<PRE>
public static char <B>couldBeZero</B>(char&nbsp;av1,
                               char&nbsp;av2)</PRE>
<DL>
<DD>The <code>couldBeZero()</code> method performs a "fuzzy" equality test against zero for two abstract
 values. It will return one of three values, depending on whether the specified abstract values are
 definately zero, definately not zero, or unknown.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD><code>AbstractArithmetic.TRUE</code> if both abstract values are definately zero;
         <code>AbstractArithmetic.FALSE</code> if either of the specified abstract values cannot
         possibly be zero (it has one bit that is known to be on); <code>AbstractArithmetic.UNKNOWN</code>
         otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="couldBeEqual(char, char)"><!-- --></A><H3>
couldBeEqual</H3>
<PRE>
public static char <B>couldBeEqual</B>(char&nbsp;av1,
                                char&nbsp;av2)</PRE>
<DL>
<DD>The <code>couldBeEqual()</code> method performs a "fuzzy" equality test between two abstract values. It
 will return one of three values, depending on whether the abstract values are definately equal,
 definately not equal, or unknown.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD><code>AbstractArithmetic.TRUE</code> if the abstract values are definately equal;
         <code>AbstractArithmetic.FALSE</code> if the abstract values are definately not equal;
         <code>AbstractArithmetic.UNKNOWN</code> otherwise</DL>
</DD>
</DL>
<HR>

<A NAME="commonMask(char, char)"><!-- --></A><H3>
commonMask</H3>
<PRE>
public static char <B>commonMask</B>(char&nbsp;av1,
                              char&nbsp;av2)</PRE>
<DL>
<DD>The <code>commonMask()</code> method computes the intersection of the known bit masks of two abstract
 values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>the intersection of the known bit masks of each abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="commonMask(char, char, char)"><!-- --></A><H3>
commonMask</H3>
<PRE>
public static char <B>commonMask</B>(char&nbsp;av1,
                              char&nbsp;av2,
                              char&nbsp;av3)</PRE>
<DL>
<DD>The <code>commonMask()</code> method computes the intersection of the known bit masks of three abstract
 values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value<DD><CODE>av3</CODE> - the third abstract value
<DT><B>Returns:</B><DD>the intersection of the known bit masks of each abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="logicalAnd(char, char)"><!-- --></A><H3>
logicalAnd</H3>
<PRE>
public static char <B>logicalAnd</B>(char&nbsp;av1,
                              char&nbsp;av2)</PRE>
<DL>
<DD>The <code>logicalAnd</code> method computes the logical bitwise AND of two abstract values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>an abstract value representing the bitwise AND of the two abstract value operands</DL>
</DD>
</DL>
<HR>

<A NAME="add(char, char)"><!-- --></A><H3>
add</H3>
<PRE>
public static char <B>add</B>(char&nbsp;av1,
                       char&nbsp;av2)</PRE>
<DL>
<DD>The <code>add()</code> method performs addition of two abstract values. It relies on the
 <code>ceiling()</code> and <code>floor()</code> functions that allow abstract addition to be expressed
 in terms of two concrete additions, resulting in a straightforward and clean implementation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>an abstract value that represents the sum of the two abstract values.</DL>
</DD>
</DL>
<HR>

<A NAME="subtract(char, char)"><!-- --></A><H3>
subtract</H3>
<PRE>
public static char <B>subtract</B>(char&nbsp;av1,
                            char&nbsp;av2)</PRE>
<DL>
<DD>The <code>add()</code> method performs subtraction of two abstract values. It relies on the
 <code>ceiling()</code> and <code>floor()</code> functions that allow abstract subtraction to be
 expressed in terms of two concrete subtractions, resulting in a straightforward and clean
 implementation.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>an abstract value that represents the difference of the two abstract values.</DL>
</DD>
</DL>
<HR>

<A NAME="increment(char)"><!-- --></A><H3>
increment</H3>
<PRE>
public static char <B>increment</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>increment()</code> method simply adds 1 to the abstract value. It is a special case of the
 <code>add()</code> that is common enough to warrant its own method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>an abstract value that represents the sum of the specified abstract value and the known value
         1</DL>
</DD>
</DL>
<HR>

<A NAME="decrement(char)"><!-- --></A><H3>
decrement</H3>
<PRE>
public static char <B>decrement</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>decrement()</code> method simply subtracts 1 to the abstract value. It is a special case of
 the <code>subtract()</code> that is common enough to warrant its own method.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>an abstract value that represents the difference of the specified abstract value and the known
         value 1</DL>
</DD>
</DL>
<HR>

<A NAME="mergeMask(char, char)"><!-- --></A><H3>
mergeMask</H3>
<PRE>
public static char <B>mergeMask</B>(char&nbsp;mask,
                             char&nbsp;av1)</PRE>
<DL>
<DD>The <code>mergeMask()</code> merges the given abstract value with the known bit mask passed. This means
 that the known bits will be the intersection of the known bits of the mask and the known bits of the
 abstract value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>mask</CODE> - the known bit mask<DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>an abstract value in which the known bit mask is the intersection of the given bit mask and the
         bit mask of the given abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="xor(char, char)"><!-- --></A><H3>
xor</H3>
<PRE>
public static char <B>xor</B>(char&nbsp;av1,
                       char&nbsp;av2)</PRE>
<DL>
<DD>The <code>xor()</code> method computes the bitwise exclusive or operation on the two given abstract
 values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>the bitwise exclusive or of the two abstract values</DL>
</DD>
</DL>
<HR>

<A NAME="and(char, char)"><!-- --></A><H3>
and</H3>
<PRE>
public static char <B>and</B>(char&nbsp;av1,
                       char&nbsp;av2)</PRE>
<DL>
<DD>The <code>and()</code> method computes the logical bitwise AND of two abstract values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>an abstract value representing the bitwise AND of the two abstract value operands</DL>
</DD>
</DL>
<HR>

<A NAME="or(char, char)"><!-- --></A><H3>
or</H3>
<PRE>
public static char <B>or</B>(char&nbsp;av1,
                      char&nbsp;av2)</PRE>
<DL>
<DD>The <code>or()</code> method computes the logical bitwise or of two abstract values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value
<DT><B>Returns:</B><DD>an abstract value representing the bitwise inclusive or of the two abstract value operands</DL>
</DD>
</DL>
<HR>

<A NAME="and(char, char, char)"><!-- --></A><H3>
and</H3>
<PRE>
public static char <B>and</B>(char&nbsp;av1,
                       char&nbsp;av2,
                       char&nbsp;av3)</PRE>
<DL>
<DD>The <code>and()</code> method computes the logical bitwise AND of three abstract values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value<DD><CODE>av3</CODE> - the third abstract value
<DT><B>Returns:</B><DD>an abstract value representing the bitwise AND of the three abstract value operands</DL>
</DD>
</DL>
<HR>

<A NAME="or(char, char, char)"><!-- --></A><H3>
or</H3>
<PRE>
public static char <B>or</B>(char&nbsp;av1,
                      char&nbsp;av2,
                      char&nbsp;av3)</PRE>
<DL>
<DD>The <code>or()</code> method computes the logical bitwise or of three abstract values.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the first abstract value<DD><CODE>av2</CODE> - the second abstract value<DD><CODE>av3</CODE> - the third abstract value
<DT><B>Returns:</B><DD>an abstract value representing the bitwise inclusive or of the two abstract value operands</DL>
</DD>
</DL>
<HR>

<A NAME="not(char)"><!-- --></A><H3>
not</H3>
<PRE>
public static char <B>not</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>not()</code> method computes the bitwise negation (one's complement) of the specified
 abstract value
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>the abstract value representing the bitwise negation of the operand</DL>
</DD>
</DL>
<HR>

<A NAME="ceiling(char)"><!-- --></A><H3>
ceiling</H3>
<PRE>
public static int <B>ceiling</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>ceiling()</code> function computes the concrete value with all unknown bits set to one. This
 is useful for implementation of some arithmetic operations.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to compute the ceiling of
<DT><B>Returns:</B><DD>a concrete value where each of the unknown bits of the abstract value are set to one</DL>
</DD>
</DL>
<HR>

<A NAME="ceiling(char, char)"><!-- --></A><H3>
ceiling</H3>
<PRE>
public static int <B>ceiling</B>(char&nbsp;av1,
                          char&nbsp;av2)</PRE>
<DL>
<DD>The <code>ceiling()</code> function computes the concrete value with all unknown bits set to one. This
 is useful for implementation of some arithmetic operations. This variant takes two abstract values
 representing the lower and upper bytes of a word and returns a concrete unsigned 16-bit word
 representing the ceiling function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value representing the lower byte<DD><CODE>av2</CODE> - the abstract value representing the high byte
<DT><B>Returns:</B><DD>a concrete word value where each of the unknown bits of the abstract value are set to one</DL>
</DD>
</DL>
<HR>

<A NAME="floor(char)"><!-- --></A><H3>
floor</H3>
<PRE>
public static int <B>floor</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>floor()</code> function computes the concrete value with all unknown bits set to zero. This
 is useful for implementation of some arithmetic operations.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to compute the ceiling of
<DT><B>Returns:</B><DD>a concrete value where each of the unknown bits of the abstract value are set to zero</DL>
</DD>
</DL>
<HR>

<A NAME="floor(char, char)"><!-- --></A><H3>
floor</H3>
<PRE>
public static int <B>floor</B>(char&nbsp;av1,
                        char&nbsp;av2)</PRE>
<DL>
<DD>The <code>floor()</code> function computes the concrete value with all unknown bits set to zero. This
 is useful for implementation of some arithmetic operations. This variant takes two abstract values
 representing the lower and upper bytes of a word and returns a concrete unsigned 16-bit word
 representing the floor function.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value representing the lower byte<DD><CODE>av2</CODE> - the abstract value representing the high byte
<DT><B>Returns:</B><DD>a concrete word value where each of the unknown bits of the abstract value are set to zero</DL>
</DD>
</DL>
<HR>

<A NAME="shiftLeftOne(char)"><!-- --></A><H3>
shiftLeftOne</H3>
<PRE>
public static char <B>shiftLeftOne</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>shiftLeftOne()</code> method shifts the abstract value left by one bit.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value
<DT><B>Returns:</B><DD>an abstract value representing the operand shifted left by one and the lower bit is set to
         known zero</DL>
</DD>
</DL>
<HR>

<A NAME="shiftLeftOne(char, char)"><!-- --></A><H3>
shiftLeftOne</H3>
<PRE>
public static char <B>shiftLeftOne</B>(char&nbsp;av1,
                                char&nbsp;lowbit)</PRE>
<DL>
<DD>The <code>shiftLeftOne()</code> method shifts the abstract value left by one bit and sets the lowest
 bit to the given value.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value<DD><CODE>lowbit</CODE> - the value of the lowest bit
<DT><B>Returns:</B><DD>an abstract value representing the operand shifted left by one and the lower bit is set to the
         given value</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char)"><!-- --></A><H3>
toString</H3>
<PRE>
public static java.lang.String <B>toString</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>toString()</code> method converts an 8-bit abstract value to a string representation. Each
 bit's value is represented as either '0', '1', or '.' and listed with the most significant first.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to convert to a string
<DT><B>Returns:</B><DD>a string representation of the abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="toShortString(char)"><!-- --></A><H3>
toShortString</H3>
<PRE>
public static java.lang.String <B>toShortString</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>toShortString()</code> method converts an 8-bit abstract value to a string representation.
 Each bit's value is represented as either '0', '1', or '.' and listed with the most significant first.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to convert to a string
<DT><B>Returns:</B><DD>a string representation of the abstract value</DL>
</DD>
</DL>
<HR>

<A NAME="bitToChar(char)"><!-- --></A><H3>
bitToChar</H3>
<PRE>
public static char <B>bitToChar</B>(char&nbsp;av1)</PRE>
<DL>
<DD>The <code>toString()</code> method converts an 1-bit abstract value to a string representation. The
 bit's value is represented as either '0', '1', or '.'.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract bit to convert to a string
<DT><B>Returns:</B><DD>a character representation of the abstract bit</DL>
</DD>
</DL>
<HR>

<A NAME="toString(char, java.lang.StringBuffer)"><!-- --></A><H3>
toString</H3>
<PRE>
public static void <B>toString</B>(char&nbsp;av1,
                            java.lang.StringBuffer&nbsp;buf)</PRE>
<DL>
<DD>The <code>toString()</code> method converts an 8-bit abstract value to a string representation and
 appends it to the end of the given string buffer. Each bit's value is represented as either '0', '1',
 or '.' and listed with the most significant first.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>av1</CODE> - the abstract value to convert to a string<DD><CODE>buf</CODE> - the string buffer to append the result to</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=3 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;PREV CLASS&nbsp;
&nbsp;<A HREF="../../avrora/stack/AbstractInterpreter.html" title="class in avrora.stack"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../index.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="AbstractArithmetic.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>

</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
